(* open Ocaml_libbpf *)
(* module F = Libbpf.Functions *)
(* module T = Libbpf.Types *)
(* module W = Fxt.Write *)
(* module B = Bindings *)

(* type poll_behaviour = Poll of int | Busywait [@@warning "-37"] *)

(* exception Exit of int *)

(* (\* Describe event handler *\) *)
(* let handle_event (rw : Ring_writer.t) _ctx data _size = *)
(*   let open Ctypes in *)
(*   let module Event = B.Struct_event in *)
(*   let event = !@(from_voidp Event.t data) in *)
(*   let pid = getf event Event.pid |> Int64.of_int in *)
(*   let tid = getf event Event.tid |> Int64.of_int in *)
(*   let comm = getf event Event.comm |> B.char_array_as_string in *)
(*   let ts = getf event Event.ts |> Unsigned.UInt64.to_int64 in *)
(*   (match getf event Event.ty with *)
(*   | B.SYS_ENTER_IO_URING_ENTER -> *)
(*       W.duration_begin rw.fxt ~name:"IO_URING_ENTER" *)
(*         ~thread:W.{ pid; tid } *)
(*         ~category:"syscalls" ~ts *)
(*   | B.SYS_EXIT_IO_URING_ENTER -> *)
(*       W.duration_end rw.fxt ~name:"IO_URING_ENTER" *)
(*         ~thread:W.{ pid; tid } *)
(*         ~category:"syscalls" ~ts *)
(*   (\* Tracepoints *\) *)
(*   | B.IO_URING_CREATE -> *)
(*       let t = getf u B.io_uring_create |> B.Struct_io_uring_create.unload in *)
(*       Ring_writer.create_event rw ~pid ~ring_fd:t.fd ~ring_ctx:t.ctx_ptr ~tid *)
(*         ~name:"io_uring_create" ~comm ~ts *)
(*   | B.IO_URING_SUBMIT_SQE -> *)
(*       let t = *)
(*         getf u B.io_uring_submit_sqe |> B.Struct_io_uring_submit_sqe.unload *)
(*       in *)
(*       let req_ptr = t.req_ptr |> Int64.of_nativeint in *)
(*       Ring_writer.submission_event rw ~pid ~ring_ctx:t.ctx_ptr ~tid *)
(*         ~name:"io_uring_submit" ~comm ~ts ~correlation_id:req_ptr *)
(*         ~args: *)
(*           [ *)
(*             ("ring_ctx", `Pointer (Int64.of_nativeint t.ctx_ptr)); *)
(*             ("req", `Pointer req_ptr); *)
(*             ("op_str", `String t.op_str); *)
(*             ("opcode", `Int64 (Int64.of_int t.opcode)); *)
(*             ("flags", `Int64 (Int64.of_int t.flags)); *)
(*             ("force_nonblock", `String (Bool.to_string t.force_nonblock)); *)
(*             ("sq_thread", `String (Bool.to_string t.sq_thread)); *)
(*           ] *)
(*   | B.IO_URING_QUEUE_ASYNC_WORK -> *)
(*       let t = *)
(*         getf u B.io_uring_queue_async_work *)
(*         |> B.Struct_io_uring_queue_async_work.unload *)
(*       in *)
(*       let req_ptr = t.req_ptr |> Int64.of_nativeint in *)
(*       Ring_writer.async_work_event rw ~pid ~ring_ctx:t.ctx_ptr ~tid *)
(*         ~name:"io_uring_queue_async_work" ~comm ~ts ~correlation_id:req_ptr *)
(*         ~args: *)
(*           [ *)
(*             ("ring_ctx", `Pointer (Int64.of_nativeint t.ctx_ptr)); *)
(*             ("req", `Pointer req_ptr); *)
(*             ("opcode", `Int64 (Int64.of_int t.opcode)); *)
(*             ("flags", `Int64 (Int64.of_int32 t.flags)); *)
(*             ("work_ptr", `Pointer t.work_ptr); *)
(*             ("op_str", `String t.op_str); *)
(*           ] *)
(*   | B.IO_URING_COMPLETE -> *)
(*       let t = getf u B.io_uring_complete |> B.Struct_io_uring_complete.unload in *)
(*       let req_ptr = t.req_ptr |> Int64.of_nativeint in *)
(*       Ring_writer.completion_event rw ~pid ~ring_ctx:t.ctx_ptr ~tid *)
(*         ~name:"io_uring_complete" ~comm ~ts ~correlation_id:req_ptr *)
(*         ~args: *)
(*           [ *)
(*             ("ring_ctx", `Pointer (Int64.of_nativeint t.ctx_ptr)); *)
(*             ("req", `Pointer req_ptr); *)
(*             ("res", `Int64 (Int64.of_int t.res)); *)
(*             ("cflags", `Int64 (Int64.of_int t.cflags)); *)
(*           ] *)
(*   | B.IO_URING_CQRING_WAIT -> *)
(*       let t = *)
(*         getf u B.io_uring_cqring_wait |> B.Struct_io_uring_cqring_wait.unload *)
(*       in *)
(*       W.instant_event rw.fxt ~name:"io_uring_cqring_wait" *)
(*         ~thread:W.{ pid; tid } *)
(*         ~category:"uring" ~ts *)
(*         ~args: *)
(*           [ *)
(*             ("ring_ctx", `Pointer (Int64.of_nativeint t.ctx_ptr)); *)
(*             ("min_events", `Int64 (Int64.of_int t.min_events)); *)
(*           ] *)
(*   | _ -> ()); *)
(*   0 *)

(* let run ?(poll_behaviour = Poll 100) handle_event = *)
(*   (\* Implicitly bump RLIMIT_MEMLOCK to create BPF maps *\) *)
(*   F.libbpf_set_strict_mode T.LIBBPF_STRICT_AUTO_RLIMIT_MEMLOCK; *)

(*   (\* Set signal handlers *\) *)
(*   let exitting = ref true in *)
(*   let sig_handler = Sys.Signal_handle (fun _ -> exitting := false) in *)
(*   Sys.(set_signal sigint sig_handler); *)
(*   Sys.(set_signal sigterm sig_handler); *)

(*   (\* Read BPF object *\) *)
(*   let obj = *)
(*     match F.bpf_object__open "uring.bpf.o" with *)
(*     | None -> *)
(*         Printf.eprintf "Failed to open BPF object\n"; *)
(*         raise (Exit 1) *)
(*     | Some obj -> obj *)
(*   in *)

(*   at_exit (fun () -> F.bpf_object__close obj); *)

(*   (\* Load BPF object *\) *)
(*   if F.bpf_object__load obj = 1 then ( *)
(*     Printf.eprintf "Failed to load BPF object\n"; *)
(*     raise (Exit 1)); *)

(*   let program_names = *)
(*     [ *)
(*       "handle_create"; *)
(*       "handle_submit"; *)
(*       "handle_queue_async_work"; *)
(*       "handle_complete"; *)
(*       "handle_cqring_wait"; *)
(*       "handle_sys_enter_io_uring_enter"; *)
(*       "handle_sys_exit_io_uring_enter"; *)
(*     ] *)
(*   in *)

(*   (\* Find program by name *\) *)
(*   let progs = *)
(*     let find_exn name = *)
(*       match F.bpf_object__find_program_by_name obj name with *)
(*       | None -> *)
(*           Printf.eprintf "Failed to find bpf program: %s\n" name; *)
(*           raise (Exit 1) *)
(*       | Some p -> p *)
(*     in *)
(*     List.map find_exn program_names *)
(*   in *)

(*   (\* Attach tracepoint *\) *)
(*   let links = *)
(*     let attach_exn prog = *)
(*       let link = F.bpf_program__attach prog in *)
(*       if F.libbpf_get_error (Ctypes.to_voidp link) <> Signed.Long.zero then ( *)
(*         Printf.eprintf "Failed to attach BPF program\n"; *)
(*         raise (Exit 1)); *)
(*       link *)
(*     in *)
(*     List.map attach_exn progs *)
(*   in *)

(*   at_exit (fun () -> *)
(*       List.iter (fun link -> F.bpf_link__destroy link |> ignore) links); *)

(*   (\* Load maps *\) *)
(*   let map = *)
(*     match F.bpf_object__find_map_by_name obj "rb" with *)
(*     | None -> *)
(*         Printf.eprintf "Failed to find map"; *)
(*         raise (Exit 1) *)
(*     | Some m -> m *)
(*   in *)
(*   let rb_fd = F.bpf_map__fd map in *)

(*   at_exit (fun () -> *)
(*       match F.bpf_object__find_map_by_name obj "globals" with *)
(*       | None -> Printf.eprintf "Failed to find globals map" *)
(*       | Some counter -> ( *)
(*           let open Ctypes in *)
(*           let sz_key = Ctypes.(sizeof int |> Unsigned.Size_t.of_int) in *)
(*           let sz_value = Ctypes.(sizeof long |> Unsigned.Size_t.of_int) in *)
(*           let key = Ctypes.(allocate int 0) in *)
(*           let value_cnt = Ctypes.(allocate long Signed.Long.zero) in *)
(*           let flags = Unsigned.UInt64.zero in *)
(*           let counter = *)
(*             F.bpf_map__lookup_elem counter (to_voidp key) sz_key *)
(*               (to_voidp value_cnt) sz_value flags *)
(*           in *)
(*           if counter <> 0 then *)
(*             Printf.eprintf "Failed to lookup element got %d\n" counter *)
(*           else *)
(*             match !@value_cnt with *)
(*             | i when i = Signed.Long.zero -> () *)
(*             | i -> *)
(*                 Printf.eprintf *)
(*                   "Failed to reserve space in Ringbuf, Dropped events %s\n" *)
(*                   (Ctypes_value_printing.string_of long i))); *)

(*   let handle_event = *)
(*     Ctypes.( *)
(*       coerce *)
(*         (Foreign.funptr ~runtime_lock:true ~check_errno:true *)
(*            (ptr void @-> ptr void @-> size_t @-> returning int)) *)
(*         T.ring_buffer_sample_fn handle_event) *)
(*   in *)

(*   (\* Set up ring buffer polling *\) *)
(*   let rb = *)
(*     match *)
(*       F.ring_buffer__new rb_fd handle_event Ctypes.null *)
(*         Ctypes.(from_voidp T.ring_buffer_opts null) *)
(*     with *)
(*     | None -> *)
(*         Printf.eprintf "Failed to create ring buffer\n"; *)
(*         raise (Exit 1) *)
(*     | Some rb -> rb *)
(*   in *)

(*   at_exit (fun () -> F.ring_buffer__free rb); *)

(*   let cb = ref 0 in *)

(*   at_exit (fun () -> Printf.printf "Consumed %d events\n" !cb); *)

(*   (match poll_behaviour with *)
(*   | Poll timeout -> *)
(*       while !exitting do *)
(*         let err = F.ring_buffer__poll rb timeout in *)
(*         match err with *)
(*         | e when e = Sys.sighup -> raise (Exit 0) *)
(*         | e when e < 0 -> *)
(*             Printf.eprintf "Error polling ring buffer, %d\n" e; *)
(*             raise (Exit 1) *)
(*         | i -> cb := !cb + i *)
(*       done *)
(*   | Busywait -> ( *)
(*       match F.ring_buffer__consume rb with *)
(*       | i when i >= 0 -> cb := !cb + i *)
(*       | e when e = Sys.sighup -> raise (Exit 0) *)
(*       | e -> *)
(*           Printf.eprintf "Error polling ring buffer, %d\n" e; *)
(*           raise (Exit 1))); *)

(*   raise (Exit 0) *)

(* let () = *)
(*   Eio_linux.run @@ fun env -> *)
(*   Eio.Switch.run (fun sw -> *)
(*       let tracefile = Eio.Path.( / ) (Eio.Stdenv.cwd env) "trace.fxt" in *)
(*       let out = Eio.Path.open_out ~sw ~create:(`Or_truncate 0o644) tracefile in *)
(*       Eio.Buf_write.with_flow out (fun w -> *)
(*           let fxt = W.of_writer w in *)
(*           let t = Ring_writer.make fxt in *)
(*           try run (handle_event t) *)
(*           with Exit i -> Printf.printf "Exit %d\n%!" i)) *)
