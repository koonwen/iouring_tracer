io_uring_tracer
* TODO
* Using Callback method
- [X] Plan out interface to decode events between libbpf and OCaml
- [ ] Implement callback function to put events into OCaml
- [ ] Implement spawning of C-thread alongside program

* Using epoll method
** Check out how to use epoll instead of callback

* Extras
** Include spans & timestamps
** Add on syscalls
** Add on kprobes
** Plan out dynamic loading

ocaml-libbpf
* TODO
** Build libbpf and hook into c_stubs (Try using ctypes)
** Write OCaml bindings for libbpf


<2024-04-08 Mon> AM
- [-] Figure out why C-thread cannot put events into the same ring
  buffer as user process
  ANS: It can, not a problem
  - [X] Get callbacks working in C
  - [X] Hook into bpf program without crashing
  - [ ] Hook into olly
  - [ ] Add in graceful shutdown
  - [ ] Memlock limit, see if BPF still needs this increase explicitly
  - [ ] Add epoll method
  - [ ] Check what low impact monitoring using C primatives for
    runtime events can do

- [-] Try to get one event written in from C
  - [X] Does C threading scheduler work pre-emptively or
    cooperatively?
    ANS: Pre-emptively. The system reserves the right
    to execute the yield command itself at any moment. In fact, it
    exercises this right sufficiently often to permit other threads to
    execute and to give the illusion that the threads are running in
    parallel, even on a uniprocessor machine.

  - [X] What happens when you don't grab the runtime lock?
    ANS: Only one thread at a time is allowed to run OCaml code on a
    particular domain, data races occur with undefined behaviour

  - [ ] How does the Event module work?

  PM
- [ ] Wrap one function from libbpf using vendoring method
  - [ ] Check initial commit for liburing
  - [ ] How does compilation process work for simple C library.
    - [ ] Static
    - [ ] Dynamic
    - [ ] Includes
    - [ ] Headers


Notes with Sadiq:
- Previously, the strace like io-uring tracer I demo-ed, utilizes
  bpftrace to bootstrap writing and loading a bpf program that logs
  io-uring events. io-uring events here could be anything from
  io-uring syscalls, static kernel tracepoints, kprobes, etc. Bpftrace
  makes it easy to hook into these points in the kernel and write
  small programs that execute when these points are hit.
  Disadvantages:
  1. Getting these logs into OCaml is a bit hacky because we get
     bpftrace process to write to separate file and get out OCaml
     process to periodically read them.
  2. This means we rely on bpftrace third party external dependency,
     which is not as extensible as we would like.

Decided to migrate from using bpftrace to libbpf implement our bpf
program (How does bpftrace work?)
  Advantages:
  - More portable
  - More fine-grain control over how the kernel program works and
    better API's like bpf-ringbuffer.
  - Instead of using file indirection to get write and read events. We
    can use the ringbuffer which maps between user and kernel
    space. Then I use OCaml callbacks to write into custom events
  Disadvantages:
  - Not easy to write, and carries along the static build of libbpf -
    incurs long build time

- Currently, I have a minimal working example for the libbpf backend
  that hooks into io_uring tracepoints and writes these events via the
  callbacks.

 Questions:
- To write the c-bindings library for libbpf, is it preferable to
  vendor the c-library as a stand-alone or require it as a system
  dependency? I see that the uring library does the former but not
  sure what's good practice.

- I tried using ctypes stub generation to implement the bindings but
  got some undefined symbols error, is it worthwhile trying to debug
  this or go for the hand written stubs?

- About the C API's for zero impact monitoring. If I use them, will
  olly have trouble visualizing this info?
