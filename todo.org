IO_URING_TRACER
* TODO
* Using Callback method
- [X] Plan out interface to decode events between libbpf and OCaml
- [ ] Implement callback function to put events into OCaml
- [ ] Implement spawning of C-thread alongside program

* Using epoll method
** Check out how to use epoll instead of callback

* Extras
** Include spans & timestamps

** Add on kprobes
** Plan out dynamic loading

ocaml-libbpf
* TODO
** Build libbpf and hook into c_stubs (Try using ctypes)
** Write OCaml bindings for libbpf

* Plan
** <2024-04-08 Mon>
*** AM
- [-] Figure out why C-thread cannot put events into the same ring
  buffer as user process
  ANS: It can, not a problem
  - [X] Get callbacks working in C
  - [X] Hook into bpf program without crashing
  - [X] Hook into olly
  - [X] Memlock limit, see if BPF still needs this increase explicitly
*** PM
- [X] Try to get one event written in from C
  - [X] Does C threading scheduler work pre-emptively or
    cooperatively?
    ANS: Pre-emptively. The system reserves the right
    to execute the yield command itself at any moment. In fact, it
    exercises this right sufficiently often to permit other threads to
    execute and to give the illusion that the threads are running in
    parallel, even on a uniprocessor machine.

  - [X] What happens when you don't grab the runtime lock?
    ANS: Only one thread at a time is allowed to run OCaml code on a
    particular domain, data races occur with undefined behaviour

** <2024-04-09 Tue>
*** AM
Fix IO_URING custom events not turining up in olly:
- [X] Try on simple custom event
  Ans: Yes you can see the events. Don't build with dune because it
  won't capture your program. There is a chance that events will be
  overwritten but olly will print this to stderr.

- [X] Look through olly implementation. What runtime buffer is being
  recorded? Does it track different threads

  Ans: all threads and ringbuffers are captured.  Need to watch out
  for the format type you are using fuchsia will capture all event
  Type's but json will only catch span's

- [X] Name the events
- [X] Write spans for syscalls (unpolished)

*** PM:
- [X] Write a test harness for watch mode and also to run your program
- [X] Does the bpf ring buffer drop messages?
  Ans: No

** <2024-04-10 Wed>
*** AM
- [X] Fix up development env for laptop
- [X] Produce some artifacts using custom events
  - [X] Interactive
  - [X] Against read_async.exe
  - [X] Against eio copy program
  - [X] Update README
*** PM
- [ ] Add in graceful shutdown

** <2024-04-11 Thu>
*** AM
- [X] Reply Tim about adding USDT probes
  ANS: Yes libbpf has API's to attach USDT probes.

*** PM
- [X] Investigate why there are recursive syscalls (programming error)
  Ans: with olly trace json, and interactive run, it looks like the
  callbacks are firing in the right linear order. olly trace fuchsia
  may be recording the events weirdly.

* Backlog:
- [ ] Replace <bpf/linux.h> with "vmlinux.h"
- [ ] Figure out how to separate running of the root bpf program and
  OCaml. Might need to be an external monitor like bpftrace
- [ ] Add custom events polling to bpftrace
- [ ] Add epoll method
- [ ] How does the Event module work?
- [ ] Check what low impact monitoring using C primatives for runtime
  events can do
- [ ] Potentially add USDT probes
- [ ] Runtime lock blocks until a poll point. This messes up the
  custom events timestamp, see if it's possible to extend custom
  events to support this- [ ] Work towards packaging and giving a talk about the tool to the internal teams

** Libbpf

- [ ] Wrap one function from libbpf using vendoring method
  - [ ] Check initial commit for liburing
  - [ ] How does compilation process work for simple C library.
    - [ ] Static
    - [ ] Dynamic
    - [ ] Includes
    - [ ] Headers

* Notes with Sadiq:
- Previously, the strace like io-uring tracer I demo-ed, utilizes
  bpftrace to bootstrap writing and loading a bpf program that logs
  io-uring events. io-uring events here could be anything from
  io-uring syscalls, static kernel tracepoints, kprobes, etc. Bpftrace
  makes it easy to hook into these points in the kernel and write
  small programs that execute when these points are hit.
  Disadvantages:
  1. Getting these logs into OCaml is a bit hacky because we get
     bpftrace process to write to separate file and get out OCaml
     process to periodically read them.
  2. This means we rely on bpftrace third party external dependency,
     which is not as extensible as we would like.

Decided to migrate from using bpftrace to libbpf implement our bpf
program (How does bpftrace work?)
  Advantages:
  - More portable
  - More fine-grain control over how the kernel program works and
    better API's like bpf-ringbuffer.
  - Instead of using file indirection to get write and read events. We
    can use the ringbuffer which maps between user and kernel
    space. Then I use OCaml callbacks to write into custom events
  Disadvantages:
  - Not easy to write, and carries along the static build of libbpf -
    incurs long build time

- Currently, I have a minimal working example for the libbpf backend
  - that hooks into io_uring tracepoints and writes these events via the
   callbacks.

  Questions:
- My custom events are appearing. Do these traces look reasonable to you?

- Need more use-cases to see whether the tool is providing useful
  trace work, It's a bit of guesswork to see what probes to add.

- To write the c-bindings library for libbpf, is it preferable to
  vendor the c-library as a stand-alone or require it as a system
  dependency? I see that the uring library does the former but not
  sure what's good practice.

- I tried using ctypes stub generation to implement the bindings but
  got some undefined symbols error, It looks like the support for
  ctypes stub generation is not particularly active. Is it worthwhile
  trying to debug this or go for the hand written stubs?

- About the C API's for zero impact monitoring. If I use them, will
  olly have trouble visualizing this info?
- About the implementation, I used callbacks instead of the polling
  method to get the notifications into OCaml

- Investigate why there are recursive syscalls (programming error)
- Work towards packaging and giving a talk about the tool to the internal teams
- runtime lock blocks until a poll point
- What kind of data are we looking for in custom events? Just the
  instance point or something more?
